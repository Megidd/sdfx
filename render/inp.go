package render

import (
	"fmt"
	"os"
	"sync"
	"time"
)

//-----------------------------------------------------------------------------

// Define the ABAQUS or CalculiX inp file requirements, if any.

//-----------------------------------------------------------------------------

// writeInpTet4 writes a stream of finite elements in the shape of tetrahedra to an ABAQUS or CalculiX `inp` file.
func writeInpTet4(wg *sync.WaitGroup, path string) (chan<- []*Tet4, error) {
	f, err := os.Create(path)
	if err != nil {
		return nil, err
	}

	_, err = f.WriteString("**\n** Structure: finite elements of a 3D model.\n** Generated by: https://github.com/deadsy/sdfx\n**\n")
	if err != nil {
		return nil, err
	}

	_, err = f.WriteString("*HEADING\nModel: 3D model Date: " + time.Now().UTC().Format("2006-Jan-02 MST") + "\n")
	if err != nil {
		return nil, err
	}

	// External code writes tetrahedra to this channel.
	// This goroutine reads the channel and writes tetrahedra to the file.
	c := make(chan []*Tet4)

	wg.Add(1)
	go func() {
		defer wg.Done()
		defer f.Close()

		_, err = f.WriteString("*NODE\n")
		if err != nil {
			fmt.Printf("%s\n", err)
			return
		}

		var nodeCount uint32 = 1 // Right, starts with 1
		var tetCount uint32 = 0  //

		// read tetrahedra from the channel and write them to the file
		for ts := range c {
			for _, t := range ts {
				_, err = f.WriteString(fmt.Sprintf("%d,%f,%f,%f\n", nodeCount, float32(t.V[0].X), float32(t.V[0].Y), float32(t.V[0].Z)))
				if err != nil {
					fmt.Printf("%s\n", err)
					return
				}
				nodeCount++
				_, err = f.WriteString(fmt.Sprintf("%d,%f,%f,%f\n", nodeCount, float32(t.V[1].X), float32(t.V[1].Y), float32(t.V[1].Z)))
				if err != nil {
					fmt.Printf("%s\n", err)
					return
				}
				nodeCount++
				_, err = f.WriteString(fmt.Sprintf("%d,%f,%f,%f\n", nodeCount, float32(t.V[2].X), float32(t.V[2].Y), float32(t.V[2].Z)))
				if err != nil {
					fmt.Printf("%s\n", err)
					return
				}
				nodeCount++
				_, err = f.WriteString(fmt.Sprintf("%d,%f,%f,%f\n", nodeCount, float32(t.V[3].X), float32(t.V[3].Y), float32(t.V[3].Z)))
				if err != nil {
					fmt.Printf("%s\n", err)
					return
				}
				nodeCount++
				tetCount++
			}
		}

		_, err = f.WriteString("*ELEMENT, TYPE=C3D4, ELSET=Eall\n")
		if err != nil {
			fmt.Printf("%s\n", err)
			return
		}

		var eleId uint32 = 1   // Right, start with 1
		var nodeIdx uint32 = 0 // Will be incremented. So will be starting from 1.

		for i := 0; i < int(tetCount); i++ {
			_, err = f.WriteString(fmt.Sprintf("%d,%d,%d,%d,%d\n", eleId, inc(&nodeIdx), inc(&nodeIdx), inc(&nodeIdx), inc(&nodeIdx)))
			if err != nil {
				fmt.Printf("%s\n", err)
				return
			}
			eleId++
		}
	}()

	return c, nil
}

// To be able to increment values in-place.
// https://stackoverflow.com/a/56015749/3405291
func inc(i *uint32) uint32 {
	*i++
	return *i
}
