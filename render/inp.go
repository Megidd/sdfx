package render

import (
	"bufio"
	"encoding/binary"
	"fmt"
	"os"
	"sync"
)

//-----------------------------------------------------------------------------

// Define the ABAQUS or CalculiX inp file requirements.

type inpNode struct {
	Id     uint32  //
	Comma0 byte    //
	X      float32 //
	Comma1 byte    //
	Y      float32 //
	Comma2 byte    //
	Z      float32 //
}

func newInpNode(id uint32, x, y, z float32) inpNode {
	return inpNode{
		Id:     id,
		Comma0: 0x2C,
		X:      x,
		Comma1: 0x2C,
		Y:      y,
		Comma2: 0x2C,
		Z:      z,
	}
}

//-----------------------------------------------------------------------------

// writeFE writes a stream of finite elements in the shape of tetrahedra to an ABAQUS or CalculiX file.
func writeFE(wg *sync.WaitGroup, path string) (chan<- []*Tetrahedron, error) {
	f, err := os.Create(path)
	if err != nil {
		return nil, err
	}

	// Use buffered IO for optimal IO writes.
	// The default buffer size doesn't appear to limit performance.
	buf := bufio.NewWriter(f)

	_, err = f.WriteString("**\n** Structure: finite elements of a 3D model.\n** Generated by: https://github.com/deadsy/sdfx\n**\n")
	if err != nil {
		return nil, err
	}

	_, err = f.WriteString("*HEADING\nModel: 3D model Date: N/A\n")
	if err != nil {
		return nil, err
	}

	_, err = f.WriteString("*NODE\n")
	if err != nil {
		return nil, err
	}

	// External code writes tetrahedra to this channel.
	// This goroutine reads the channel and writes tetrahedra to the file.
	c := make(chan []*Tetrahedron)

	wg.Add(1)
	go func() {
		defer wg.Done()
		defer f.Close()

		var nodeCount uint32 = 1 // Right, starts with 1
		var node inpNode         // To avoid memory declaration inside the heavy loop.

		// read tetrahedra from the channel and write them to the file
		for ts := range c {
			for _, t := range ts {
				node = newInpNode(nodeCount, float32(t.V[0].X), float32(t.V[0].Y), float32(t.V[0].Z))
				if err := binary.Write(buf, binary.LittleEndian, &node); err != nil {
					fmt.Printf("%s\n", err)
					return
				}
				nodeCount++
				node = newInpNode(nodeCount, float32(t.V[1].X), float32(t.V[1].Y), float32(t.V[1].Z))
				if err := binary.Write(buf, binary.LittleEndian, &node); err != nil {
					fmt.Printf("%s\n", err)
					return
				}
				nodeCount++
				node = newInpNode(nodeCount, float32(t.V[2].X), float32(t.V[2].Y), float32(t.V[2].Z))
				if err := binary.Write(buf, binary.LittleEndian, &node); err != nil {
					fmt.Printf("%s\n", err)
					return
				}
				nodeCount++
				node = newInpNode(nodeCount, float32(t.V[2].X), float32(t.V[2].Y), float32(t.V[2].Z))
				if err := binary.Write(buf, binary.LittleEndian, &node); err != nil {
					fmt.Printf("%s\n", err)
					return
				}
				nodeCount++
			}
		}

		// flush the tetrahedra
		buf.Flush()
	}()

	return c, nil
}
