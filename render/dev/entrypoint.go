package dev

import (
	"github.com/deadsy/sdfx/sdf"
	"github.com/hajimehoshi/ebiten"
	"github.com/subchen/go-trylock/v2"
	"math"
	"net/http"
	"net/rpc"
	"sync"
	"time"
)

// Renderer is a SDF2/SDF3 renderer intended for fast development iterations that renders directly to a window.
// The first time, it starts the renderer process. It also starts listening for code changes.
// When a code change is detected, the app is recompiled (taking advantage of go's fast compilation times)
// by the renderer and communicates directly to the renderer, responding evaluate queries for the new SDF.
//
// It allows very fast SDF updates (saving camera position) whenever the code changes, speeding up the modelling process.
// The renderer is mainly CPU-based (with a resolution parameter to control speed vs quality), as sdfx is also CPU-based.
// The scene is only rendered when something changes, as rendering SDFs with good quality is not real-time.
//
// SDF2s are rendered with the PNG renderer, showing the image directly on screen (without creating the PNG file).
// The camera can be moved and scaled (using the mouse), rendering only the interesting part of the SDF.
//
// SDF3s are raycasted from a perspective arc-ball camera that can be moved around and rotated (using Blender-like mouse controls).
// Note that only the shown surface is actually rendered thanks to raycasting from the camera.
// This also means that the resulting surface can be much more detailed (depending on chosen resolution)
// than the triangle meshes generated by standard renderers.
//
// It uses [ebiten](https://github.com/hajimehoshi/ebiten) for rendering, which is cross-platform, so it also could
// be used to showcase a surface (without automatic updates) using a standalone desktop, web or mobile.
type Renderer struct {
	impl                devRendererImpl   // the implementation to use SDF2/SDF3/remote process.
	implState           *DevRendererState // the renderer's state, so impl can be swapped while keeping the state.
	implStateLock       *sync.RWMutex     // the renderer's state lock
	cachedRender        *ebiten.Image     // the latest cached render (to avoid rendering every frame, or frame parts even if nothing changed)
	cachedRenderBb2     sdf.Box2          // what part of the SDF2 the latest cached render represents (no optimization available for SDF3s)
	cachedPartialRender *ebiten.Image     // the latest partial render (to display render progress visually)
	cachedRenderLock    *sync.RWMutex
	screenSize          sdf.V2i           // the screen Resolution
	renderingCtxCancel  func()            // non-nil if we are currently rendering
	renderingLock       trylock.TryLocker // locked when we are rendering, use renderingCtx to cancel the previous render
	translateFrom       sdf.V2i
	translateFromStop   sdf.V2i
}

// NewDevRenderer see DevRenderer
func NewDevRenderer(anySDF interface{}) *Renderer {
	r := &Renderer{
		implState:         newDevRendererState(),
		implStateLock:     &sync.RWMutex{},
		cachedRenderLock:  &sync.RWMutex{},
		renderingLock:     trylock.New(),
		translateFrom:     sdf.V2i{math.MaxInt, math.MaxInt},
		translateFromStop: sdf.V2i{math.MaxInt, math.MaxInt},
	}
	switch s := anySDF.(type) {
	case sdf.SDF2:
		r.impl = newDevRenderer2(s)
		r.cachedRenderBb2 = s.BoundingBox()
	//case sdf.SDF3:
	default:
		panic("anySDF must be either a SDF2 or a SDF3")
	}
	return r
}

func (r *Renderer) Run() error {
	// TODO: Find a renderer (environment variable) and connect to it
	// TODO: Otherwise create the renderer and listen for connections (or try to connect in the case of HTTP)
	newDevRendererService(r.impl).HandleHTTP("/", "/debug")
	go http.ListenAndServe(":8549", http.DefaultServeMux)
	time.Sleep(100 * time.Millisecond)
	dialHTTP, err := rpc.DialHTTP("tcp", ":8549")
	if err != nil {
		return err
	}
	remoteRenderer := newDevRendererClient(dialHTTP)
	r.impl = remoteRenderer
	return ebiten.RunGame(r)
}
