package dev

import (
	"github.com/deadsy/sdfx/sdf"
	"github.com/hajimehoshi/ebiten"
	"github.com/subchen/go-trylock/v2"
	"image"
	"math"
	"os"
	"os/exec"
	"sync"
)

// Renderer is a SDF2/SDF3 renderer intended for fast development iterations that renders directly to a window.
// The first time, it starts the renderer process. It also starts listening for code changes.
// When a code change is detected, the app is recompiled (taking advantage of go's fast compilation times)
// by the renderer and communicates directly to the renderer, responding evaluate queries for the new SDF.
//
// It allows very fast SDF updates (saving camera position) whenever the code changes, speeding up the modelling process.
// The renderer is mainly CPU-based (with a resolution parameter to control speed vs quality), as sdfx is also CPU-based.
// The scene is only rendered when something changes, as rendering SDFs with good quality is not real-time.
//
// SDF2s are rendered with the PNG renderer, showing the image directly on screen (without creating the PNG file).
// The camera can be moved and scaled (using the mouse), rendering only the interesting part of the SDF.
//
// SDF3s are raycasted from a perspective arc-ball camera that can be moved around and rotated (using Blender-like mouse controls).
// Note that only the shown surface is actually rendered thanks to raycasting from the camera.
// This also means that the resulting surface can be much more detailed (depending on chosen resolution)
// than the triangle meshes generated by standard renderers.
//
// It uses [ebiten](https://github.com/hajimehoshi/ebiten) for rendering, which is cross-platform, so it also could
// be used to showcase a surface (without automatic updates) using a standalone desktop, web or mobile.
type Renderer struct {
	impl                devRendererImpl // the implementation to use SDF2/SDF3/remote process.
	implLock            *sync.RWMutex   // the implementation lock
	implState           *RendererState  // the renderer's state, so impl can be swapped while keeping the state.
	implStateLock       *sync.RWMutex   // the renderer's state lock
	cachedRender        *ebiten.Image   // the latest cached render (to avoid rendering every frame, or frame parts even if nothing changed)
	cachedRenderCpu     *image.RGBA     // the latest cached render (to avoid rendering every frame, or frame parts even if nothing changed)
	cachedRenderBb2     sdf.Box2        // what part of the SDF2 the latest cached render represents (no optimization available for SDF3s)
	cachedPartialRender *ebiten.Image   // the latest partial render (to display render progress visually)
	cachedRenderLock    *sync.RWMutex
	screenSize          sdf.V2i           // the screen ResInv
	renderingCtxCancel  func()            // non-nil if we are currently rendering
	renderingLock       trylock.TryLocker // locked when we are rendering, use renderingCtx to cancel the previous render
	translateFrom       sdf.V2i
	translateFromStop   sdf.V2i
}

// NewDevRenderer see DevRenderer
func NewDevRenderer(anySDF interface{}) *Renderer {
	r := &Renderer{
		implLock:          &sync.RWMutex{},
		implStateLock:     &sync.RWMutex{},
		cachedRenderLock:  &sync.RWMutex{},
		renderingLock:     trylock.New(),
		translateFrom:     sdf.V2i{math.MaxInt, math.MaxInt},
		translateFromStop: sdf.V2i{math.MaxInt, math.MaxInt},
	}
	switch s := anySDF.(type) {
	case sdf.SDF2:
		r.impl = newDevRenderer2(s)
		r.cachedRenderBb2 = s.BoundingBox()
	//case sdf.SDF3:
	default:
		panic("anySDF must be either a SDF2 or a SDF3")
	}
	r.implState = r.newRendererState()
	return r
}

const RequestedAddressEnvKey = "SDFX_DEV_RENDERER_CHILD"

func (r *Renderer) Run(runCmd func() *exec.Cmd, watchGlobs ...string) error {
	requestedAddress := os.Getenv(RequestedAddressEnvKey)
	if requestedAddress != "" { // Found a parent renderer (environment variable)
		return r.runChild(requestedAddress)
	} else { // Otherwise, listen for code changes to spawn a child renderer and create the local renderer
		return r.runRenderer(runCmd, watchGlobs)
	}
}
