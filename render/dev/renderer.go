package dev

import (
	"github.com/deadsy/sdfx/sdf"
	"github.com/hajimehoshi/ebiten"
	"github.com/subchen/go-trylock/v2"
	"math"
	"sync"
)

// Renderer is a SDF2/SDF3 renderer intended for fast development iterations that renders directly to a window.
// The first time, it starts the renderer process. It also starts listening for code changes.
// When a code change is detected, the app is recompiled (taking advantage of go's fast compilation times)
// by the renderer and communicates directly to the renderer, responding evaluate queries for the new SDF.
// The renderer is mainly CPU-based, as SDFs are also defined for the CPU.
//
// SDF2s are rendered with the PNG renderer (using the generated image directly) and shown on screen.
// They can be zoomed in and translated (using the mouse), forcing a rerender for higher quality.
// Only the shown bounding box is rendered.
//
// SDF3s are raycasted from a perspective arc-ball camera (Blender controls) that can be moved around and rotated,
// forcing a rerender when transformed.
// Note that only the shown surface is actually rendered thanks to raycasting from the camera.
// This also means that the resulting surface can be much more detailed (depending on chosen resolution) than the
// triangle meshes generated by standard renderers.
//
// TODO: Debug bounding boxes
// TODO: Click to identify SDFs affecting the touched surface (maybe in file:line format to copy-paste)
//
// It uses [ebiten](https://github.com/hajimehoshi/ebiten) for rendering, which is cross-platform, so it also could
// be used to showcase a surface using a standalone desktop, HTML5, mobile or Nintendo Switch app.
type Renderer struct {
	impl                devRendererImpl   // the implementation to use SDF2/SDF3/remote process.
	implState           *devRendererState // the renderer's state, so impl can be swapped while keeping the state.
	implStateLock       *sync.RWMutex     // the renderer's state lock
	cachedRender        *ebiten.Image     // the latest cached render (to avoid rendering every frame, or frame parts even if nothing changed)
	cachedRenderBb2     sdf.Box2          // what part of the SDF2 the latest cached render represents (no optimization available for SDF3s)
	cachedPartialRender *ebiten.Image     // the latest partial render (to display render progress visually)
	cachedRenderLock    *sync.RWMutex
	screenSize          sdf.V2i           // the screen resolution
	renderingCtxCancel  func()            // non-nil if we are currently rendering
	renderingLock       trylock.TryLocker // locked when we are rendering, use renderingCtx to cancel the previous render
	translateFrom       sdf.V2i
}

// TODO: Use Voxel cache for faster camera rotations

// NewDevRenderer see DevRenderer
func NewDevRenderer(anySDF interface{}) *Renderer {
	r := &Renderer{
		implState:        newDevRendererState(),
		implStateLock:    &sync.RWMutex{},
		cachedRenderLock: &sync.RWMutex{},
		renderingLock:    trylock.New(),
		translateFrom:    sdf.V2i{math.MaxInt, math.MaxInt},
	}
	switch s := anySDF.(type) {
	case sdf.SDF2:
		r.impl = newDevRenderer2(s)
		r.cachedRenderBb2 = s.BoundingBox()
	//case sdf.SDF3:
	default:
		panic("anySDF must be either a SDF2 or a SDF3")
	}
	return r
}

func (r *Renderer) Run() error {
	// TODO: Find a renderer (environment variable) and connect to it
	// TODO: Otherwise create the renderer and listen for connections (or try to connect in the case of HTTP)
	return ebiten.RunGame(r)
}
