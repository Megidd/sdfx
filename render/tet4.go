package render

import (
	"fmt"
	"os"
	"sync"
	"time"

	"github.com/deadsy/sdfx/render/buffer"
	"github.com/deadsy/sdfx/sdf"
	v3 "github.com/deadsy/sdfx/vec/v3"
)

// Tet4 is a 3D tetrahedron consisting of 4 nodes.
// It's a kind of finite element, FE.
// https://en.wikipedia.org/wiki/Tetrahedron
type Tet4 struct {
	// Coordinates of 4 corner nodes or vertices.
	V [4]v3.Vec
	// The layer to which tetrahedron belongs. Layers are along Z axis.
	// For finite element analysis - FEA - of 3D printed objects, it's more efficient to store layer along Z axis.
	// The 3D print is done along the Z axis. Likewise, FEA is done along the Z axis.
	// Sampling/marching algorithm is expected to generate finite elements along the Z axis.
	layer int
}

// A mesh of tetrahedra with 4 nodes.
// A sophisticated data structure for mesh is required to store tetrahedra.
// The repeated nodes would be removed.
// The element connectivity would be created with unique nodes.
type MeshTet4 struct {
	// Index buffer.
	// Every 4 indices would correspond to a tetrahedron. Low-level for performance.
	// Tetrahedra are stored by their layer on Z axis.
	T [][]uint32
	// Vertex buffer.
	// All coordinates are unique.
	// Used to avoid repeating vertices when adding a new tetrahedron.
	VBuff *buffer.Tet4VB
}

// To get a new mesh and number of its layers along Z-axis.
func NewMeshTet4(s sdf.SDF3, r RenderTet4) (*MeshTet4, int) {
	tet4s := ToTet4(s, r)

	_, _, layerCountZ := r.LayerCounts(s)

	m := newMeshTet4(layerCountZ)

	// Fill out the mesh with finite elements.
	for _, t := range tet4s {
		m.addTet4(t.layer, t.V[0], t.V[1], t.V[2], t.V[3])
	}

	defer m.VBuff.DestroyHashTable()

	return m, layerCountZ
}

func newMeshTet4(layerCount int) *MeshTet4 {
	t := &MeshTet4{
		T:     nil,
		VBuff: nil,
	}

	// Initialize.
	t.T = make([][]uint32, layerCount)
	for l := 0; l < layerCount; l++ {
		t.T[l] = make([]uint32, 0)
	}

	// Initialize
	t.VBuff = buffer.NewTet4VB()

	return t
}

// Layer number and 4 nodes are input.
// The node numbering should follow the convention of CalculiX.
// http://www.dhondt.de/ccx_2.20.pdf
func (m *MeshTet4) addTet4(l int, a, b, c, d v3.Vec) {
	m.T[l] = append(m.T[l], m.addVertex(a), m.addVertex(b), m.addVertex(c), m.addVertex(d))
}

func (m *MeshTet4) addVertex(vert v3.Vec) uint32 {
	return m.VBuff.Id(vert)
}

func (m *MeshTet4) vertexCount() int {
	return m.VBuff.VertexCount()
}

func (m *MeshTet4) vertex(i uint32) v3.Vec {
	return m.VBuff.Vertex(i)
}

// Number of layers along the Z axis.
func (m *MeshTet4) layerCount() int {
	return len(m.T)
}

// Number of tetrahedra on a layer.
func (m *MeshTet4) tet4CountOnLayer(l int) int {
	return len(m.T[l]) / 4
}

// Number of tetrahedra for all layers.
func (m *MeshTet4) tet4Count() int {
	var count int
	for _, l := range m.T {
		count += len(l) / 4
	}
	return count
}

// Layer number is input.
// Tetrahedron index on layer is input.
// Tetrahedron index could be from 0 to number of tetrahedra on layer.
// Don't return error to increase performance.
func (m *MeshTet4) tet4Indicies(l, i int) (uint32, uint32, uint32, uint32) {
	return m.T[l][i*4], m.T[l][i*4+1], m.T[l][i*4+2], m.T[l][i*4+3]
}

// Layer number is input.
// Tetrahedron index on layer is input.
// Tetrahedron index could be from 0 to number of tetrahedra on layer.
// Don't return error to increase performance.
func (m *MeshTet4) tet4Vertices(l, i int) (v3.Vec, v3.Vec, v3.Vec, v3.Vec) {
	return m.VBuff.Vertex(m.T[l][i*4]), m.VBuff.Vertex(m.T[l][i*4+1]), m.VBuff.Vertex(m.T[l][i*4+2]), m.VBuff.Vertex(m.T[l][i*4+3])
}

// Write mesh to ABAQUS or CalculiX `inp` file.
func (m *MeshTet4) WriteInp(path string) error {
	return m.WriteInpLayers(path, 0, m.layerCount())
}

// Write specific layers of mesh to ABAQUS or CalculiX `inp` file.
// Result would include start layer.
// Result would exclude end layer.
func (m *MeshTet4) WriteInpLayers(path string, layerStart, layerEnd int) error {
	if 0 <= layerStart && layerStart < layerEnd && layerEnd <= m.layerCount() {
		// Good.
	} else {
		return fmt.Errorf("start or end layer is beyond range")
	}

	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()

	// Write headers.

	_, err = f.WriteString("**\n** Structure: finite elements of a 3D model.\n** Generated by: https://github.com/deadsy/sdfx\n**\n")
	if err != nil {
		return err
	}

	_, err = f.WriteString("*HEADING\nModel: 3D model Date: " + time.Now().UTC().Format("2006-Jan-02 MST") + "\n")
	if err != nil {
		return err
	}

	// Write nodes.

	_, err = f.WriteString("*NODE\n")
	if err != nil {
		return err
	}

	// To write only required nodes to the file.
	vsBuff := buffer.NewTet4VB()
	defer vsBuff.DestroyHashTable()

	var node0, node1, node2, node3 v3.Vec
	var id0, id1, id2, id3 uint32
	for l := layerStart; l < layerEnd; l++ {
		for i := 0; i < m.tet4CountOnLayer(l); i++ {
			node0, node1, node2, node3 = m.tet4Vertices(l, i)
			id0 = vsBuff.Id(node0)
			id1 = vsBuff.Id(node1)
			id2 = vsBuff.Id(node2)
			id3 = vsBuff.Id(node3)
			// ID starts from one not zero.
			_, err = f.WriteString(fmt.Sprintf("%d,%f,%f,%f\n", id0+1, float32(node0.X), float32(node0.Y), float32(node0.Z)))
			if err != nil {
				return err
			}
			// ID starts from one not zero.
			_, err = f.WriteString(fmt.Sprintf("%d,%f,%f,%f\n", id1+1, float32(node1.X), float32(node1.Y), float32(node1.Z)))
			if err != nil {
				return err
			}
			// ID starts from one not zero.
			_, err = f.WriteString(fmt.Sprintf("%d,%f,%f,%f\n", id2+1, float32(node2.X), float32(node2.Y), float32(node2.Z)))
			if err != nil {
				return err
			}
			// ID starts from one not zero.
			_, err = f.WriteString(fmt.Sprintf("%d,%f,%f,%f\n", id3+1, float32(node3.X), float32(node3.Y), float32(node3.Z)))
			if err != nil {
				return err
			}
		}
	}

	// Write elements.

	_, err = f.WriteString("*ELEMENT, TYPE=C3D4, ELSET=Eall\n")
	if err != nil {
		return err
	}

	var eleID uint32
	for l := layerStart; l < layerEnd; l++ {
		for i := 0; i < m.tet4CountOnLayer(l); i++ {
			node0, node1, node2, node3 = m.tet4Vertices(l, i)
			id0 = vsBuff.Id(node0)
			id1 = vsBuff.Id(node1)
			id2 = vsBuff.Id(node2)
			id3 = vsBuff.Id(node3)
			// ID starts from one not zero.
			_, err = f.WriteString(fmt.Sprintf("%d,%d,%d,%d,%d\n", eleID+1, id0+1, id1+1, id2+1, id3+1))
			if err != nil {
				return err
			}
			eleID++
		}
	}

	return nil
}

//-----------------------------------------------------------------------------

// writeTet4 writes a stream of finite elements, in the shape of 4-node tetrahedra, to an array.
func writeTet4(wg *sync.WaitGroup, tet4s *[]Tet4) chan<- []*Tet4 {
	// External code writes tetrahedra to this channel.
	// This goroutine reads the channel and stores tetrahedra.
	c := make(chan []*Tet4)

	wg.Add(1)
	go func() {
		defer wg.Done()
		// read finite elements from the channel and handle them
		for ts := range c {
			for _, t := range ts {
				*tet4s = append(*tet4s, *t)
			}
		}
	}()

	return c
}

//-----------------------------------------------------------------------------
